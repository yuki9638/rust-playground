use std::io;
// まずuse文を追加して標準ライブラリからstd::cmp::Orderingという型をスコープに導入しています。
//Orderingもenumの一つでLess、Greater、Equalという列挙子を持っています。 これらは二つの値を比較したときに得られる3種類の結果です
use std::cmp::Ordering;
use rand::Rng;
// stdって標準ライブラリの中に入っているioっていう入出力を管理するライブラリをスコープに入れる
// rustでは標準ライブラリで定義されている関数をいくつか全てのプログラムのスコープに取り込みこのセットの名前をpreludeと呼ぶ。
// preludeの中身を見たい場合は
// https://doc.rust-lang.org/std/prelude/index.html
// を参照。
// 使いたい型がpreludeにない場合は、その型をuse文で明示的にスコープに入れる必要がある
fn main() {
    println!("Guess the number!");
    // rand::thread_rng関数を呼び出して、これから使う、ある特定の乱数生成器を取得しています。
    // そして、この乱数生成器のgen_rangeメソッドを呼び出しています。
    // このメソッドはuse rand::Rng文でスコープに導入したRngトレイトで定義されています

    let secret_number = rand::thread_rng().gen_range(1..101);
    // println!("The secret number is: {}", secret_number);
    loop{
        println!("Please input your guess.");
        
        // ユーザの入力を格納するための変数を作る
        // Rustでは変数はデフォルトで不変（immutable）になります
        // 変数を可変（mutable）にするには、変数名の前にmutをつけます。
        // 等号記号（=）はRustに、いまこの変数を何かに束縛したいことを伝えます
        // Stringは標準ライブラリによって提供される文字列型で、サイズが拡張可能な、
        // UTF-8でエンコードされたテキスト片
        // ::構文はnewがString型の関連関数であることを示しています(型宣言)
        let mut guess = String::new();
        
        // ここでioモジュールのstdin関数を呼び出して、ユーザ入力を処理できるようにしている
        // use std::ioと書いてioライブラリをインポートしていなかったとしても、std::io::stdinのように呼び出せば、この関数を利用できます。
        // stdin関数はターミナルの標準入力へのハンドルを表す型であるstd::io::Stdinのインスタンスを返します。
        io::stdin()
            // .read_line(&mut guess)行は、標準入力ハンドルのread_lineメソッドを呼び出し、ユーザからの入力を得ています。
            // また、read_lineの引数として&mut guessを渡し、ユーザ入力をどの文字列に格納するかを指示しています
            // &は、この引数が参照であることを示し、これによりコードの複数の部分が同じデータにアクセスしても、そのデータを何度もメモリにコピーしなくて済みます
            // あと、Rust では メソッドチェーン をするとき、. は前の式にくっつけて書かないといけない
            // だからここでは;で終わらせちゃだめ
            .read_line(&mut guess)
            // read_lineメソッドは渡された文字列にユーザが入力したものを入れます。 しかし、同時に値（この場合はio::Result）も返します。
            // 汎用のResultと、io::Resultといったサブモジュール用の特殊な型がある
            // Result型は列挙型になります。 列挙型はenumとも呼ばれ、取りうる値として決まった数の列挙子（variant）を持ちます。
            // 列挙型はよくmatchと一緒に使われます。
            // これは条件式の一種で、評価時に、列挙型の値がどの列挙子であるかに基づいて異なるコードを実行できるという便利なものです。
            // Result型の目的は、エラー処理に関わる情報を符号化（エンコード）することです。
            // Resultの列挙子はOkかErrです。
            // Ok列挙子は処理が成功したことを示し、Okの中には正常に生成された値が入っています。
            // Err列挙子は処理が失敗したことを意味し、Errには処理が失敗した過程や理由についての情報が含まれています。
            // Result型の値にも、他の型と同様にメソッドが定義されています
            // io::Resultのインスタンスにはexpectメソッドがありますので、これを呼び出せます。
            // このio::ResultインスタンスがErrの値の場合、expectメソッドはプログラムをクラッシュさせ、引数として渡されたメッセージを表示します。
            // もしexpectメソッドを呼び出さなかったら、コンパイルはできるものの警告が出るでしょう。
            // std::fs::read_to_string("hello.txt").expect("ファイルを開けません");
            // match std::fs::read_to_string("hello.txt") {
            //    Ok(content) => println!("{}", content),
            //    Err(e) => println!("エラー: {}", e),
            //}
            //上のプログラムのようにresult型の返り値を持つ関数を呼び出す時には、expectメソッドやunwrapメソッドをよびださないとコンパイル時にエラーが出る
            //警告を抑制する正しい方法は実際にエラー処理を書くことです
            //クラッシュさせたいだけならexpect()が使える

            .expect("Failed to read line");
        // 一組の波括弧の{}はプレースホルダーです。 
        // 波括弧をいくつか使えば複数の値を表示できます。
        // 最初の波括弧の組はフォーマット文字列のあとに並んだ最初の値に対応し、2組目は2番目の値、というように続いていきます。

        // Rustではguessの前の値を新しい値で覆い隠す（shadowする）ことが許されている
        // シャドーイング（shadowing）は、guess_strとguessのような重複しない変数を二つ作る代わりに、guessという変数名を再利用させてくれるのです。
        // この機能はある型から別の型に値を変換するときによく使われることを知っておいてください。
        // この新しい変数をguess.trim().parse()という式に束縛しています。
        
        // 式の中にあるguessは、入力が文字列として格納されたオリジナルのguess変数を指しています。
        // Stringインスタンスのtrimメソッドは文字列の先頭と末尾の空白をすべて削除します。
        // これは数値データのみを表現できるu32型とこの文字列を比較するために（準備として）行う必要があります。
        // ユーザは予想を入力したあとread_lineの処理を終えるためにEnterキーを押す必要がありますが、これにより文字列に改行文字が追加されます。
        
        // 文字列のparseメソッドは文字列をパース（解析）して何らかの数値にします
        // このメソッドは（文字列を）さまざまな数値型へとパースできる
        // let guess: u32としてRustに正確な数値型を伝える必要があります
        // guessの後にコロン（:）を付けることで変数の型に注釈をつけることをRustに伝えています
        // Rustには組み込みの数値型がいくつかあります。 
        // u32は符号なし32ビット整数
        // 小さな正の数を表すデフォルトの型に適しています。

        // parseメソッドは論理的に数値に変換できる文字にしか使えないので、よくエラーになります。
        // たとえば文字列にA👍%が含まれていたら数値に変換する術はありません
        // 解析に失敗する可能性があるため、parseメソッドはread_lineメソッドと同様にResult型を返します

    let guess: u32 = match guess.trim().parse(){
            Ok(num) => num,
            Err(_) => continue,
        };
        println!("You guessed: {}",guess);
        // cmpメソッドは二つの値の比較を行い、比較できるものになら何に対しても呼び出せます。
        // 比較対象への参照をとり、ここではguessとsecret_numberを比較しています。
        // ここではmatch式を使用しており、guessとsecret_numberの値に対してcmpを呼んだ結果返されたOrderingの列挙子に基づき、次の動作を決定しています。
        // match式は複数のアーム（腕）で構成されます。
        // 各アームはマッチさせるパターンと、matchに与えられた値がそのアームのパターンにマッチしたときに実行されるコードで構成されます。
        // パターン=>コード
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),       //小さすぎ！
            Ordering::Greater => println!("Too big!"),      //大きすぎ！
            Ordering::Equal => {
                println!("You win!");
                break;
                    }        //やったね！
        }
    }
}
// クレートはRustソースコードを集めたものである
// バイナリクレート: 実行ファイル
// randクレート: ライブラリクレート
// Cargo.tomlファイルでは、ヘッダに続くものはすべて、他のセクションが始まるまで続くセクションの一部になります。 
//（訳注：Cargo.tomlファイル内には複数のセクションがあり、各セクションは[ ]で囲まれたヘッダ行から始まります）
// 外部依存を持つようになると、Cargoはその依存関係が必要とするすべてについて最新のバージョンをレジストリから取得します。
// レジストリとはCrates.ioのデータのコピーです。
// Crates.ioは、Rustのエコシステムにいる人たちがオープンソースのRustプロジェクトを投稿し、他の人が使えるようにする場所です。

// つまり、外部ライブラリを使いたい時はcargo.tomlにそのライブラリのバージョンの番号を書けばコンパイル時に自動で何とかしてくれるってこと

// クレートは勝手にはアップグレードされない。
// 最初にコンパイルした時にCargo.lockの中にその時使ったクレートのバージョンを書き込んで、ビルドされる時にそこを参照するから
// クレートを本当にアップグレードしたくなったときのために、Cargoはupdateコマンドを提供します
// このコマンドはCargo.lockファイルを無視して、Cargo.tomlファイル内の全ての指定に適合する最新バージョンを算出します
